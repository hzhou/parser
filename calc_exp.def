include: calc_lex.def

include: DefParser/parser.def
include: DefParser/parser_pattern.def

subcode:: _autoload
    $global n_prec
    $list parse_expression

# -----------------------------------------
fncode: parse_expression
    $return_type double *
    return parse_add()

    # ---------------
    $list parse_prime

    &call op_left, add, mult, '+', '-'
	$if *ts_op=='+'
	    $call do_binary_op, +
	$else
	    $call do_binary_op, -

    &call op_left, mult, pow, '*', '/', '%'
	$if *ts_op=='*'
	    $call do_binary_op, *
	$elif *ts_op=='%'
	    $call do_binary_op, /
	$else
	    *tp_a=(int)(*tp_a) % (int)(*tp_b)

    &call op_right, pow, prime, '^'
	*tp_a = pow(*tp_a, *tp_b)

fncode: parse_prime
    $list match_Number
    $call parse_return_type

    $call input_start
    $if match_char('(')
	$call input_start
	tp_a=parse_expression()
	$call expect, ')'
	return tp_a
    $elif tp_a=match_Number()
	return tp_a
    $elif match_identifier()
	tp_a=NULL
	$call get_ts_token
	skip_space()
	tb_has_bracket=0
	$if match_char('(')
	    tb_has_bracket=1
	$call @parse_exp_list
	$if tb_has_bracket
	    $fcall match_bracket('(')
	$call @do_function_call
	return tp_a
    $else
	return NULL
	
# -------------------------------------
subcode: debug_fcall
    # print Running $(FunctionName) ...

subcode: op_left(name, parse, @op_list)
    $call build_op_macro, $(op_list)
    $function parse_$(name)
	$call parse_return_type
	$if tp_a=parse_$(parse)()
	    $call input_start
	    $while $(op)
		ts_op=$(input)->buffer+$(input)->n_start
		skip_space()
		tp_b=parse_$(parse)()
		$if !tp_b
		    $call @parse_error, parse_$(parse)
		BLOCK
		free(tp_b)
		$call input_start
	    return tp_a
	$else
	    return NULL

subcode: op_right(name, parse, @op_list)
    $call build_op_macro, $(op_list)
    $function parse_$(name)
	$call parse_return_type
	$if tp_a=parse_$(parse)()
	    $call input_start
	    $if $(op)
		ts_op=$(input)->buffer+$(input)->n_start
		skip_space()
		tp_b=parse_$(name)()
		$if !tp_b
		    $call @parse_error, parse_$(parse)
		BLOCK
		free(tp_b)
		$call input_start
	    return tp_a
	$else
	    return NULL
